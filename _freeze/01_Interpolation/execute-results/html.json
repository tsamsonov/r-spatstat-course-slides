{
  "hash": "e10dad31cf62d3c837d91476d2ab41be",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Детерминистическая интерполяция и аппроксимация\"\nsubtitle: \"Пространственная статистика\"\ndate: today\ndate-format: long\nauthor: \"Самсонов Тимофей Евгеньевич\"\nexecute:\n  echo: false\n  freeze: true\nengine: knitr\nformat:\n  revealjs: \n    theme: [default, custom.scss]\n    margin: 0.2\n    width: 1280\n    height: 720\n    slide-number: true\n    footer: \"Самсонов Т. Е. Пространственная статистика: курс лекций\"\n    header-includes: <link rel=\"stylesheet\" media=\"screen\" href=\"https://fontlibrary.org//face/pt-sans\" type=\"text/css\"/>\nbibliography: references.yaml\nmainfont: PT Sans\n---\n\n\n## Детерминистическая интерполяция\n\n-   **Интерполяция** в общем случае — это способ нахождения промежуточных значений величины по имеющемуся дискретному набору известных значений\n\n-   Методы которые производят интерполяцию на основе заданной аналитической зависимости, называют **детерминистическими**.\n\n-   Параметры этой зависимости могут быть как априори заданы пользователем, так и определяться автоматически одним из методов оптимизации\n\n-   Предполагается что анализируемые данные описываются некоторой аналитической функцией $Z(p, \\lambda)$, где $p$ — точка, а $\\lambda$ — набор внутренних параметров модели.\n\n-   Задача: на основе известных данных $Z_i = Z(p_i)$, измеренных в точках $p_i$, и другой информации об исследуемом явлении подобрать набор параметров $\\lambda$ и построить функцию $Z(p, \\lambda)$ для всей исследуемой области $S$.\n\n## Узлы интерполяции\n\n-   Как правило, оценка производится по регулярной сетке узлов\n-   В общем случае положение узлов интерполяции произвольно\n\n![](images/pts.png)\n\n## Сетка (растр) интерполяции\n\nКаждый узел регулярной сетки можно сопоставить с центром ячейки, что обеспечивает сплошное покрытие и позволяет построить изолинии распределения показателя\n\n![](images/cells.png)\n\n## Триангуляция Делоне и диаграмма Вороного\n\n::: columns\n::: {.column width=\"50%\"}\n![](images/tin.png){width=\"100%\"}\n:::\n\n::: {.column width=\"50%\"}\n**Триангуляция** (на плоскости) — это разбиение фигуры на треугольники.\n\n> Под триангуляцией множества точек понимается триангуляция их выпуклой оболочки, в которой сами точки являются вершинами треугольников.\n\n**Диаграмма Вороного** однозначно соответствует триангуляции Делоне и строится на основе серединных перпендикуляров к сторонам треугольников\n:::\n:::\n\n## Линейные интерполяторы\n\nИскомая функция в произвольной точке $\\mathbf{p}$ ищется в виде линейной комбинации:\n\n$$Z^{*}(\\mathbf{p}) = \\sum_{p_i \\in D(\\mathbf{p})} w_i (\\mathbf{p}) Z(\\mathbf{p}_i),$$ где:\n\n-   $Z^{*}(\\mathbf{p})$ — оцениваемое значение в точке $\\mathbf{p}$,\n-   $Z(\\mathbf{p}_i)$ — известные значения в точках $\\mathbf{p}_i$,\n-   $D(\\mathbf{p})$ — множество точек $\\mathbf{p}_i$, из некоторой окрестности точки p, определяемой расстоянием или количеством,\n-   $w_i(\\mathbf{p})$ — нормированный вес точки $\\mathbf{p}_i$ для точки $\\mathbf{p}$\n\n## Метод ближайшего соседа {.p-large}\n\n-   Каждый узел интерполяции $p$ получает значение, равное значению ближайшей к нему точки наблюдений $p_k$\n\n-   Множество $D$ состоит из единственной точки $p_k (w_k = 1)$, в полигон Вороного которой попадает точка $p$.\n\n-   Результатом является ступенчатая поверхность, где в пределах зоны влияния каждой точки $p_i$ значение функции постоянно и равно $Z(p_i)$\n\n## Метод ближайшего соседа\n\nВсю область интерполяции можно разбить с помощью диаграммы Вороного на зоны принадлежности к точкам наблюдений\n\n![](images/voron1.png)\n\n## Метод ближайшего соседа\n\nВ пределах каждой ячейки значений интерполируемой величины считается постоянным\n\n![](images/voron2.png)\n\n## Метод ближайшего соседа\n\nКаждый узел интерполяции получает значение, равное значению ближайшей к нему точки наблюдений\n\n![](images/voron3.png)\n\n## Метод ближайшего соседа\n\nРезультирующая поверхность является кусочно-постоянной\n\n![](images/voron4.png)\n\n## Метод ближайшего соседа\n\nРезультирующая поверхность является кусочно-постоянной\n\n![](images/voron5.png)\n\n## Метод естественного соседа\n\nМножество $D$ состоит из точек $p_i$, которые являются соседями точки p при встраивании ее в диаграмму Вороного точек $p_i$.\n\n::: columns\n::: {.column width=\"50%\"}\nВеса определяются из соотношения:\n\n$$w_i(p) = A(v \\cap v_i) / A(v)$$\n\n-   $v_i$ — зона влияния точки $p_i$ в исходной диаграмме Вороного,\n\n-   $v$ — зона влияния точки $p$ при ее встраивании в диаграмму,\n\n-   $A$ — площадь зоны влияния,\n\n-   $\\cap$ — пересечение\n:::\n\n::: {.column width=\"50%\"}\n![](images/natural.png)\n:::\n:::\n\n## Интерполяция на основе триангуляции\n\nДля выполнения интерполяции на первом этапе необходимо для каждого треугольника найти уравнение плоскости, которое содержит четыре неизвестных коэффициента:\n\n$$Ax + By + Cz + D = 0$$\n\n$$z(x, y) = -\\frac{1}{C}(Ax+By+D)$$\n\nИмея три точки $p_1$, $p_2$ и $p_3$, искомые коэффициенты $A, B, C, D$ можно получить путем решения уравнения, левая часть которого задана в форме определителя: $$\\begin{vmatrix}\nx - x_1 & y - y_1 & z - z_1 \\\\ \nx_2 - x_1 & y_2 - y_1 & z_2 - z_1 \\\\ \nx_3 - x_1 & y_3 - y_1 & z_3 - z_1\n\\end{vmatrix} = 0$$\n\n## Интерполяция на основе триангуляции\n\nЛинейная интерполяция:\n\n![](images/tin_linear.png)\n\n## Интерполяция на основе триангуляции\n\nТакже возможно применение бикубической интерполяции, или **метода Акимы**, который позволяет сгладить поверхность за счет применения полиномов $5$-й степени, которые содержит $21$ коэффициент:\n\n$$z(x, y) = \\sum_{j=0}^5 \\sum_{k=0}^{5-j} q_{jk} x^j y^k$$\n\n-   Значения функции, а также ее первых и вторых частных производных ( $z$, $z_x$, $z_y$, $z_{xx}$, $z_{xx}$ и $z_{yy}$) задаются в каждой вершине треугольника, что дает $18$ дополнительных условий.\n\n-   Производные \"склеиваются\" по трем сторонам между смежными треугольниками, что дает еще $3$ условия.\n\n## Интерполяция на основе триангуляции\n\nМетод Акимы:\n\n![](images/tin_akima.png)\n\n## Метод обратно взвешенных расстояний\n\nВеса определяются обратно пропорционально расстоянию: чем дальше исходная точка удалена, тем меньший вес она будет иметь в оценке.\n\n$$z(\\mathbf{p}) = \\begin{cases}\n\\dfrac{\\sum_{i = 1}^{N}{ w_i(\\mathbf{p}) z_i } }{ \\sum_{i = 1}^{N}{ w_i(\\mathbf{p}) } }, & \\text{если } d(\\mathbf{p},\\mathbf{p}_i) \\neq 0 \\text{ для всех } i, \\\\\n z_i, & \\text{если } d(\\mathbf{p},\\mathbf{p}_i) = 0 \\text{ для одного } i,\n\\end{cases}$$\n\nгде $w_i(\\mathbf{p}) = | \\mathbf p - \\mathbf p_i | ^{-\\beta}$ --- весовая функция.\n\nМетод **Шепарда** — одна из распространенных модификаций, в которой степень весовой функции равна $2$:\n\n$$w_i(p) = | \\mathbf p - \\mathbf p_i | ^{-2}$$\n\n## Метод обратно взвешенных расстояний\n\n$\\beta = 2$\n\n![](images/idw2.png)\n\n## Метод обратно взвешенных расстояний\n\n$\\beta = 3$\n\n![](images/idw3.png)\n\n## Метод обратно взвешенных расстояний\n\n$\\beta = 4$\n\n![](images/idw4.png)\n\n## Метод обратно взвешенных расстояний\n\n$\\beta = 5$\n\n![](images/idw5.png)\n\n## Метод обратно взвешенных расстояний\n\n$\\beta \\rightarrow \\infty$\n\n![](images/idwoo.png) В предельном случае метод IDW вырождается в метод ближайшего соседа\n\n## Радиальные базисные функции\n\n**Радиальной функцией** называется вещественнозначная функция, значение которой зависит только от расстояния между аргументом $\\textbf{p}$ и некой фиксированной точкой в пространстве $\\textbf{c}$:\n\n$$\\phi(\\textbf{p}, \\textbf{c}) = \\phi\\big(\\lVert \\textbf{p} - \\textbf{c}\\rVert\\big)$$\n\n*Базисными* радиальные функции называются когда их линейная комбинация используется для приближения произвольных вещественнозначных функций:\n\n$$Z(\\textbf{p}) = \\sum_{i=1}^n \\lambda_i \\phi\\big(\\lVert \\textbf{p} - \\textbf{p}_i\\rVert\\big)$$\n\nИменно этот принцип используется в соответствующем методе интерполяции.\n\n## Радиальные базисные функции\n\nИспользуя условие $Z(\\textbf{p}_i) = z_i$ равенства интерполированного значения исходному, получаем систему линейных уравнений следующего вида, из которой находятся искомые коэффициенты $\\lambda_i$:\n\n\n```{=tex}\n\\begin{equation}\n  \\begin{pmatrix}\n      z_1 \\\\\n      \\vdots\\\\\n      z_n\n  \\end{pmatrix} = \n  \\begin{pmatrix}\n      A_{11} & \\dots  & A_{1n} \\\\\n      \\vdots & \\ddots & \\vdots \\\\\n      A_{n1} & \\dots  & A_{nn}\n  \\end{pmatrix}\n  \\begin{pmatrix}\n      \\lambda_1 \\\\\n      \\vdots\\\\\n      \\lambda_n\n  \\end{pmatrix}\n\\end{equation}\n```\n\nгде $A_{ij} = \\phi\\big(\\lVert \\textbf{p}_i - \\textbf{p}_j\\rVert\\big)$, $i, j = 1, 2, ..., n$.\n\nЗаписав данную систему в матричном виде $\\mathbf{z} = \\mathbf{A} \\boldsymbol{\\lambda}$, найти искомые коэффициенты можно путем обращения матрицы $\\mathbf{A}$ (в случае если ее определитель не равен нулю):\n\n$$\\boldsymbol{\\lambda} = \\mathbf{A}^{-1} \\mathbf{z}$$\n\n## Радиальные базисные функции\n\nМетод **РБФ** является одним из самых гибких благодаря широким возможностям выбора радиальной функции.\n\nК числу широко используемых радиальных функций относятся:\n\n-   *Мультиквадрики*: $\\phi(r) = \\sqrt{r^2 + \\delta^2}$\n\n-   *Обратные мультиквадрики*: $\\phi(r) = 1 / \\sqrt{r^2 + \\delta^2}$\n\n-   *Мульти-логарифмическая*: $\\phi(r) = \\ln(r^2 + \\delta^2)$\n\n-   *Сплайны минимальной кривизны*: $\\phi(r) = r^2 \\ln(r^2 + \\delta^2)$\n\n> Недостатком метода РБФ является то, что поверхность может выходить за пределы исходного диапазона значений (хотя и обязательно проходит через исходные точки).\n\n## Радиальные базисные функции\n\n**Сплайн минимальной кривизны** (*thin plate spline — TPS*), дает поверхность, обладающую максимально низкой кривизной между исходными точками.\n\n![](images/spline.png)\n\n## Глобальная регрессия\n\nИспользуется для глобальной аппроксимации тренда\n\n$$P_1(x, y) = a + bx + cy$$ $$P_{1.5}(x, y) = a + bx + cy + dxy$$ $$P_{2}(x, y) = a + bx + cy + dxy + ex^2 + fy^2$$ Неизвестные коэффициенты находятся по методу наименьших квадратов решением системы линейных уравнений относительно коэффициентов a, b и т.д. Минимизируется функция потери:\n\n$$L = \\sum_{i=1}^{n} \\Large[Z(x_i, y_i) - P_k(x_i, y_i) \\Large]^2$$\n\n## Глобальная регрессия\n\nПусть дана модель линейной регрессии $z = X \\beta$. Тогда полное выражение для функции потерь имеет вид:\n\n$$L = \\lVert X \\beta - z \\rVert ^2 = (X \\beta - z)^T (X \\beta - z) \\\\= z^T z - z^T X \\beta - \\beta^T X^T z + \\beta^T X^T X \\beta$$ Далее находят производную этой функции:\n\n$$\\frac{\\partial L}{\\partial \\beta} = \\underbrace{\\frac{\\partial (z^T z)}{\\partial \\beta}}_{0} - \\underbrace{\\frac{\\partial (z^T X \\beta)}{\\partial \\beta}}_{X^T z} - \\underbrace{\\frac{\\partial (\\beta^T X^T z)}{\\partial \\beta}}_{X^T z} + \\underbrace{\\frac{\\partial (\\beta^T X^T X \\beta)}{\\partial \\beta}}_{2 X^T X \\beta} = \\\\ = - 2X^T z + 2 X^T X \\beta,$$\n\n## Глобальная регрессия\n\nПроизводная второй компоненты по правилу $\\frac{d(\\color{red}{A^T} b)}{db} = A$:\n\n$$\\frac{\\partial (\\color{red}{z^T X} \\beta)}{\\partial \\beta} = (z^T X)^T = X^T z$$ Производная третьей компоненты по правилу $\\frac{d(b^t\\color{red}{A})}{db} = A$:\n\n$$\\frac{\\partial (\\beta^T \\color{red}{X^T z})}{\\partial \\beta} = X^T z$$ Производная четвертой компоненты по правилу $\\frac{d(b^T \\color{red}{A} b)}{db} = 2\\color{red}{A}b$:\n\n$$\\frac{\\partial (\\beta^T \\color{red}{X^T X} \\beta)}{\\partial \\beta} = 2 \\color{red}{X^T X} \\beta$$\n\n## Глобальная регрессия\n\nПоскольку функция потерь является неотрицательной квадратичной, ее минимум достигается в точке, где производная равняется нулю:\n\n$$- 2X^T z + 2 X^T X \\beta = 0$$ Отсюда получаем:\n\n$$X^T X \\beta = X^T z$$ Перенеся коэффициенты перед $\\beta$ в правую часть уравнения, получаем:\n\n$$\\color{red}{\\boxed{\\color{blue}{\\beta = (X^T X)^{-1} X^T z}}}$$\n\n## Глобальная регрессия\n\nВ общем случае уравнение полиномиальной регрессии:\n\n$$z_i \\,=\\, \\beta_0 + \\beta_1 x_i + \\beta_2 x_i^2 + \\cdots + \\beta_m x_i^m + \\varepsilon_i\\  (i = 1, 2, \\dots , n)$$ Может быть переписано в матричной форме:\n\n$$\\begin{bmatrix} z_1\\\\ z_2\\\\ z_3 \\\\ \\vdots \\\\ z_n \\end{bmatrix}= \\begin{bmatrix} 1 & x_1 & x_1^2 & \\dots & x_1^m \\\\ 1 & x_2 & x_2^2 & \\dots & x_2^m \\\\ 1 & x_3 & x_3^2 & \\dots & x_3^m \\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 1 & x_n & x_n^2 & \\dots & x_n^m \\end{bmatrix} \\begin{bmatrix} \\beta_0\\\\ \\beta_1\\\\ \\beta_2\\\\ \\vdots \\\\ \\beta_m \\end{bmatrix} + \\begin{bmatrix} \\varepsilon_1\\\\ \\varepsilon_2\\\\ \\varepsilon_3 \\\\ \\vdots \\\\ \\varepsilon_n \\end{bmatrix}$$\n\nИли в краткой форме: $\\vec z = \\mathbf{X} \\vec \\beta + \\vec\\varepsilon.$\n\n## Глобальная регрессия\n\nАналогичным образом для плоскости:\n\n$$z_i = \\beta_0 + \\beta_1x_i + \\beta_2y_i$$ Уравнение для вычисления коэффициентов быть переписано в матричной форме:\n\n$$\\begin{bmatrix} z_1\\\\ z_2\\\\ z_3 \\\\ \\vdots \\\\ z_n \\end{bmatrix}= \\begin{bmatrix} 1 & x_1 &  y_1 \\\\ 1 & x_2 &  y_2 \\\\ 1 & x_3 &  y_3 \\\\ \\vdots & \\vdots & \\vdots \\\\ 1 & x_n & y_n \\end{bmatrix} \\begin{bmatrix} \\beta_0\\\\ \\beta_1\\\\ \\beta_2\\end{bmatrix} + \\begin{bmatrix} \\varepsilon_1\\\\ \\varepsilon_2\\\\ \\varepsilon_3 \\\\ \\vdots \\\\ \\varepsilon_n \\end{bmatrix}$$\n\n## Глобальная регрессия\n\nДля поверхности 2-й степени:\n\n$$z_i = \\beta_0 + \\beta_1 x_i + \\beta_2 y_i + \\beta_3 x_iy_i + \\beta_4 x_i^2 + \\beta_5 y_i^2$$ Уравнение для вычисления коэффициентов быть переписано в матричной форме:\n\n$$\\begin{bmatrix} z_1\\\\ z_2\\\\ z_3 \\\\ \\vdots \\\\ z_n \\end{bmatrix}= \\begin{bmatrix} 1 & x_1 & y_1 & x_1y_1 & x^2_1 & y^2_1 \\\\ 1 & x_2 &  y_2 & x_2y_2 & x^2_2 & y^2_2 \\\\ 1 & x_3 & y_3 & x_3y_3 & x^2_3 & y^2_3 \\\\ \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\ 1 & x_n & y_n & x_ny_n & x^2_n & y^2_n \\end{bmatrix} \\begin{bmatrix} \\beta_0\\\\ \\beta_1\\\\ \\beta_2 \\\\ \\beta_3 \\\\ \\beta_4 \\\\ \\beta_5 \\end{bmatrix} + \\begin{bmatrix} \\varepsilon_1\\\\ \\varepsilon_2\\\\ \\varepsilon_3 \\\\ \\vdots \\\\ \\varepsilon_n \\end{bmatrix}$$\n\n## Глобальная регрессия\n\nПолином степени 1\n\n![](images/approx1.png)\n\n## Глобальная регрессия\n\nПолином степени 2\n\n![](images/approx2.png)\n\n## Глобальная регрессия\n\nПолином степени 3\n\n![](images/approx3.png)\n\n## Локальная регрессия\n\nПусть дано $n$ точек исходных данных с координатами $x$ (независимая переменная) и $y$ (зависимая).\n\n<br> Задается число $0 < \\alpha \\leq 1$, которое обозначает долю от общего количества точек $n$, выбираемую в окрестности каждой точки для построения регрессии.\n\n<br> Тогда вес, который будет иметь каждая $k$-я точка исходных данных в уравнении регрессии для $i$-й точки исходных данных будет определяться по формуле:\n\n$$w_k (x_i) = W\\big((x_k - x_i)h_r^{-1}\\big),$$\n\nгде $h_i$ — расстояние до $r = [\\alpha n]$-го по близости соседа точки $x_i$, а $W$ — *весовая функция*.\n\n## Локальная регрессия\n\n**Весовая функция** отвечает следующим условиям:\n\n1.  $W(x) > 0$ если $|x| < 1$;\n2.  $W(-x) = W(x)$;\n3.  $W(x)$ невозрастающая функция для $x \\geq 0$;\n4.  $W(x) = 0$ если $|x| \\geq 1$\n\nОдним из стандартных вариантов весовой функции является *\"трикубическая\"*:\n\n$$W(x) = \\begin{cases}\n(1 - |x|^3)^3, & \\text{если } |x| < 1, \\\\\n 0, & \\text{если } |x| \\geq 1.\n\\end{cases}$$\n\nСогласно определению весовой функции более близкие к $x_i$ точки оказывают большее влияние на коэффициенты регрессии. Помимо этого за пределами расстояния $h_i$ веса всех точек исходных данных будут обнуляться.\n\n## Локальная регрессия\n\nСглаженная оценка $\\hat{y}_i$ в точке $x_i$ получается в виде полинома степени $d$:\n\n$$\\hat{y}_i = \\sum_{j=0}^d \\hat{\\beta}_j (x_i) x_i^j,$$\n\nгде коэффициенты $\\hat{\\beta}_j$ находятся методом наименьших квадратов путем минимизации ошибки:\n\n$$\\sum_{k=1}^n w_k (x_i) (y_k - \\beta_0 - \\beta_1 x_k - ... - \\beta_d x_k^d)^2$$\n\nПроцедура поиска коэффициентов регрессии повторяется для каждой из $n$ точек.\n\n## Локальная регрессия\n\nПолином степени 0 (горизонтальная плоскость)\n\n![](images/lowess0.png)\n\n## Локальная регрессия\n\nПолином степени 1 (наклонная плоскость)\n\n![](images/lowess1.png)\n\n## Локальная регрессия\n\nПолином степени 2\n\n![](images/lowess2.png)\n\n## Иерархические базисные сплайны\n\nПусть дана область $\\Omega = \\big\\{(x, y)~|~0 \\leq x < m,~ 0 \\leq y < n \\big\\}$ и множество точек $P$ нерегулярно распределенных в этой области.\n\nДля выполнения интерполяции на эту область накладывается сетка $\\Phi$ размером $(m + 3) \\times (n + 3)$. Это гарантирует, что каждая точка $P$ (в том числе, находящаяся на границе $\\Omega$) будет окружена окрестностью из $4 \\times 4 = 16$ узлов сетки ):\n\n![Расчетная сетка поверх области исходных данных](images/mba_domain.png){width=\"40%\"}\n\n## Иерархические базисные сплайны\n\nПусть сетка $\\Phi$ состоит из узлов $\\phi_{ij}$ и значения индексов меняются в следующих пределах: $i = -1, 0, ..., m + 1, ~ j = -1, 0, ..., n + 1$.\n\nТогда функция аппроксимации в узле $\\phi_{ij}$ определяется следующим образом:\n\n$$f(x, y) = \\sum_{k=0}^3 \\sum_{l=0}^3 B_k(s)B_l(t) \\phi_{i+k, j+l},$$\n\nгде $i = \\lfloor x \\rfloor -1$, $j = \\lfloor y \\rfloor -1$, $s = x - \\lfloor x \\rfloor$ и $t = y - \\lfloor y \\rfloor$.\n\n## Иерархические базисные сплайны\n\n$$f(x, y) = \\sum_{k=0}^3 \\sum_{l=0}^3 B_k(s)B_l(t) \\phi_{i+k, j+l},$$\n\nФункции $B_k$ и $B_l$ представляют собой **кубические базисные функции** в форме B-сплайнов, определяемые как:\n\n$$B_0(t) = (1-t)^3/6,\\\\\nB_1(t) = (3t^3 - 6t^2 + 4)/6,\\\\\nB_2(t) = (-3t^3 + 3t^2 + 3t + 1)/6,\\\\\nB_3(t) = t^3/6,$$\n\nгде $0 \\leq t < 1$. Данные функции служат в качестве весовых коэффициентов соответствующих узлов при определении значения в точке $(x, y)$.\n\n## Иерархические базисные сплайны\n\n$$f(x, y) = \\sum_{k=0}^3 \\sum_{l=0}^3 B_k(s)B_l(t) \\phi_{i+k, j+l},$$\n\nИнтерполируемые значения $\\phi_{ij}$ находятся исходя из условия прохождения функции $f(x, y)$ через точки исходных данных.\n\nДля значения $z_c$ в точке $(x_c, y_c) ~|~ 1 \\leq x_c, y_c < 2$ условие прохождения можно записать как:\n\n$$z_c = \\sum_{k=0}^3 \\sum_{l=0}^3 w_{kl} \\phi_{kl},$$\n\nгде $w_{kl} = B_k(s) B_l(t), s = x_c - 1, t = y_c - 1$.\n\n## Иерархические базисные сплайны\n\n$$z_c = \\sum_{k=0}^3 \\sum_{l=0}^3 w_{kl} \\phi_{kl},$$\n\nПоскольку существует множество значений $\\phi_{kl}$, которые удовлетворяют приведенному соотношению, выбирается то их сочетание, которое минимизирует сумму их квадратов $\\sum_{k=0}^3 \\sum_{l=0}^3 \\phi^2_{kl}$. Стратегически это позволяет уменьшить отклонение функции $f$ относительно нуля по области $\\Omega$.\n\nРешая задачу по методу наименьших квадратов, можно получить следующее выражение для значения в узле сетки $\\phi_{kl}$:\n\n$$\\phi_{kl} = \\frac{w_{kl} z_c}{\\sum_{a=0}^3 \\sum_{b=0}^3 w^2_{ab}}$$\n\nФункция $f(x,y)$, построенная таким образом, будет равна $z_c$ в точке $(x_c, y_c)$.\n\n## Иерархические базисные сплайны\n\nВ одной окрестности может оказаться более чем одна точка:\n\n![Перекрытие окрестностей (слева) и множество близких данных (справа)](images/mba_proximity.png){width=\"60%\"}\n\nПри расчетах вводится понятие *множества близких данных* (proximity dataset): только исходные точки, попадающие в окрестность $4 \\times 4$ ячейки относительно расчетного узла, могут оказывать влияние на его значение.\n\n## Иерархические базисные сплайны\n\nДля того, чтобы найти компромисс между значениями, индуцируемыми в узле разными точками $\\phi_c$, минимизируется функция ошибки:\n\n$$e(\\phi_{ij}) = \\sum_c (w_c \\phi_{ij} - w_c \\phi_c)^2.$$\n\nФигурирующее в ней выражение $w_c \\phi_{ij} - w_c \\phi_c$ представляет собой разницу между реальным и ожидаемым вкладом $\\phi_{ij}$ в значение функции $f$ в точке $(x_c, y_c)$. Дифференцируя $e(\\phi_{ij})$ по $\\phi_{ij}$, получаем итоговое выражение для значения в узле интерполяции $\\phi_{ij}$:\n\n$$\\phi_{ij} = \\frac{\\sum_c w_c^2 \\phi_c}{\\sum_c w_c^2}.$$\n\nЕсли окрестность не содержит ни одной точки, то $\\phi_{ij}$ принимается равным $0$.\n\n## Иерархические базисные сплайны\n\nВ методе иерархических базисных сплайнов используется *иерархия сеток* $\\Phi_0, \\Phi_1, ..., \\Phi_h$, наложенных на область $\\Omega$.\n\n<br> На каждом последующем уровне вложенности, разрешение сетки удваивается. Это означает, что:\n\n-   если сетка $\\Phi_k$ имела размер $(m +3) \\times (n + 3)$, то на уровне $\\Phi_{k+1}$ ее размеры будут соответствовать $(2m + 3) \\times (2n + 3)$.\n\n-   расположение узла с координатами $(i, j)$ на сетке $\\Phi_k$ совпадает с располоожением узла $(2i, 2j)$ на сетке $\\Phi_{k+1}$\n\n## Иерархические базисные сплайны\n\nИнтерполяция производится последовательно в направлении увеличения детализации сетки.\n\n1.  На первой итерации на сетке $\\Phi_0$ получают функцию $f_0$ и соответствующие ей отклонения в точках исходных данных $\\Delta^1 z_c = z_c - f_0(x_c, y_c)$. <br>\n2.  Далее на сетке $\\Phi_1$ в качестве $f_1$ интерполируются уже не исходные величины $z_c$, а отклонения $\\Delta^1 z_c$. <br>\n3.  Сумма $f_0 + f_1$ позволяет вычислить отклонения второго порядка: $\\Delta^2 z_c = z_c - f_0(x_c, y_c) - f_1(x_c, y_c)$ в каждой точке $(x_c, y_c)$.\n\n## Иерархические базисные сплайны\n\nОбобщая данный подход, можно сказать, что на $k$-м уровне иерархии находится функция $f_k$, которая аппроксимирует значения отклонения на предыдущем уровне:\n\n$$\\Delta^k z_c = z_c - \\sum_{i=0}^{k-1} f_i (x_c, y_c) = \\Delta^{k-1} z_c - f_{k-1} (x_c, y_c),$$\n\nгде $\\Delta^0 z_c = z_c$.\n\nФинальные значения в узлах сетки определяются суммой функций по всем уровням иерархии:\n\n$$f = \\sum_{k=0}^h f_k$$\n\n## Иерархические базисные сплайны\n\nВ данном методе поверхность представляется как сумма кусочно-полиномиальных функций, определяемых на основе двумерных базисных сплайнов\n\n![](images/bspline.png)\n\n## Поле потенциала\n\nНаиболее часто метод потенциалов используется при анализе расселения. Существует 2 альтернативных подхода к расчету:\n\n<br> **По населенным пунктам.** В этом случае каждому населенному пункту необходимо сопоставить его радиус:\n\n$$V_{i} = \\frac{P_i}{r_i} + \\sum_j \\frac{P_j}{d_{ij}},$$ где $P_i$ — людность $i$-го населенного пункта, $r_i$ — его радиус, $d_{ij}$ — расстояние между $i$-м и $j$-м населенным пунктом.\n\nВ этом случае вычисленные значение необходимо далее интерполировать на заданную сетку.\n\n## Поле потенциала\n\nНаиболее часто метод потенциалов используется при анализе расселения. Существует 2 альтернативных подхода к расчету:\n\n<br> **В любых произвольно заданных локациях.**\n\n$$V_{p} = \\sum_i \\frac{P_i}{d_{pi}},$$ В этом случае можно делать расчеты сразу на заданную сетку. При этом необходимо принудительно ограничивать минимально возможное значение $d$, чтобы потенциал не стал бесконечным.\n\n## Интерполяция по ареалам\n\n**Пикнофилактический** *(сохраняющий объем)* метод Тоблера.\n\nСледующее условие должно выполняться для всех площадных единиц:\n\n$$\\int \\int_{R_i} Z(x,y) dx dy = H_i,$$\n\nгде $R_i$ --- $i$-я площадная единица, $H_i$ --- исходное значение показателя, привязанное к $i$-й единице\n\n> Tobler W.R. Smooth Pycnophylactic Interpolation for Geographical Regions / W.R. Tobler // Journal of the American Statistical Association. – 1979. – Vol. 74. – № 367. – P. 519.\n\n## Интерполяция по ареалам\n\n**Пикнофилактический** *(сохраняющий объем)* метод Тоблера.\n\n1.  Наложить растровую сетку поверх площадных единиц.\n2.  Вычислить значения в ячейках путем деления величины показателя на количество ячеек, попавших внутрь единицы.\n3.  Осреднить значения в ячейках методом плавающего окна $3 \\times 3$. *Обычно используется правило ладьи.*\n4.  Нормировать полученные значения таким образом, чтобы их сумма внутри каждой единицы совпала с изначальной.\n\nШаги 3-4 повторяются требуемое число раз.\n\n## Интерполяция по ареалам\n\n**Пикнофилактический** *(сохраняющий объем)* метод Тоблера.\n\n![Исходные данные](images/pycno_0.png){width=\"80%\"}\n\n## Интерполяция по ареалам\n\n**Пикнофилактический** *(сохраняющий объем)* метод Тоблера.\n\n![Результат интерполяции](images/pycno.png){width=\"100%\"}\n\n## Библиография\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}